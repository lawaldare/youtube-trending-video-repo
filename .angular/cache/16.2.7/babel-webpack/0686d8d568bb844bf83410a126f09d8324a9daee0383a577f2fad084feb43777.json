{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { ElementRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, ContentChild, Input, NgModule } from '@angular/core';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil, startWith, filter } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport * as i4 from 'ng-zorro-antd/icon';\nimport { NzIconDirective, NzIconModule } from 'ng-zorro-antd/icon';\nimport * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i5 from 'ng-zorro-antd/core/transition-patch';\nimport { ɵNzTransitionPatchModule } from 'ng-zorro-antd/core/transition-patch';\nimport { NzWaveModule } from 'ng-zorro-antd/core/wave';\nconst _c0 = [\"nz-button\", \"\"];\nfunction NzButtonComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 1);\n  }\n}\nconst _c1 = [\"*\"];\nconst NZ_CONFIG_MODULE_NAME = 'button';\nlet NzButtonComponent = /*#__PURE__*/(() => {\n  class NzButtonComponent {\n    insertSpan(nodes, renderer) {\n      nodes.forEach(node => {\n        if (node.nodeName === '#text') {\n          const span = renderer.createElement('span');\n          const parent = renderer.parentNode(node);\n          renderer.insertBefore(parent, span, node);\n          renderer.appendChild(span, node);\n        }\n      });\n    }\n    get iconOnly() {\n      const listOfNode = Array.from(this.elementRef?.nativeElement?.childNodes || []);\n      const noText = listOfNode.every(node => node.nodeName !== '#text');\n      // ignore icon and comment\n      const noSpan = listOfNode.filter(node => {\n        return !(node.nodeName === '#comment' || !!node?.attributes?.getNamedItem('nz-icon'));\n      }).length == 0;\n      const isIconOnly = !!this.nzIconDirectiveElement && noSpan && noText;\n      return isIconOnly;\n    }\n    constructor(ngZone, elementRef, cdr, renderer, nzConfigService, directionality) {\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.nzConfigService = nzConfigService;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzBlock = false;\n      this.nzGhost = false;\n      this.nzSearch = false;\n      this.nzLoading = false;\n      this.nzDanger = false;\n      this.disabled = false;\n      this.tabIndex = null;\n      this.nzType = null;\n      this.nzShape = null;\n      this.nzSize = 'default';\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n      this.loading$ = new Subject();\n      this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME).pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.cdr.markForCheck();\n      });\n    }\n    ngOnInit() {\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n      this.ngZone.runOutsideAngular(() => {\n        // Caretaker note: this event listener could've been added through `host.click` or `HostListener`.\n        // The compiler generates the `ɵɵlistener` instruction which wraps the actual listener internally into the\n        // function, which runs `markDirty()` before running the actual listener (the decorated class method).\n        // Since we're preventing the default behavior and stopping event propagation this doesn't require Angular to run the change detection.\n        fromEvent(this.elementRef.nativeElement, 'click', {\n          capture: true\n        }).pipe(takeUntil(this.destroy$)).subscribe(event => {\n          if (this.disabled && event.target?.tagName === 'A' || this.nzLoading) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n          }\n        });\n      });\n    }\n    ngOnChanges(changes) {\n      const {\n        nzLoading\n      } = changes;\n      if (nzLoading) {\n        this.loading$.next(this.nzLoading);\n      }\n    }\n    ngAfterViewInit() {\n      this.insertSpan(this.elementRef.nativeElement.childNodes, this.renderer);\n    }\n    ngAfterContentInit() {\n      this.loading$.pipe(startWith(this.nzLoading), filter(() => !!this.nzIconDirectiveElement), takeUntil(this.destroy$)).subscribe(loading => {\n        const nativeElement = this.nzIconDirectiveElement.nativeElement;\n        if (loading) {\n          this.renderer.setStyle(nativeElement, 'display', 'none');\n        } else {\n          this.renderer.removeStyle(nativeElement, 'display');\n        }\n      });\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    static #_ = this.ɵfac = function NzButtonComponent_Factory(t) {\n      return new (t || NzButtonComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzButtonComponent,\n      selectors: [[\"button\", \"nz-button\", \"\"], [\"a\", \"nz-button\", \"\"]],\n      contentQueries: function NzButtonComponent_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NzIconDirective, 5, ElementRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nzIconDirectiveElement = _t.first);\n        }\n      },\n      hostAttrs: [1, \"ant-btn\"],\n      hostVars: 32,\n      hostBindings: function NzButtonComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex === null ? null : ctx.tabIndex)(\"disabled\", ctx.disabled || null);\n          i0.ɵɵclassProp(\"ant-btn-primary\", ctx.nzType === \"primary\")(\"ant-btn-dashed\", ctx.nzType === \"dashed\")(\"ant-btn-link\", ctx.nzType === \"link\")(\"ant-btn-text\", ctx.nzType === \"text\")(\"ant-btn-circle\", ctx.nzShape === \"circle\")(\"ant-btn-round\", ctx.nzShape === \"round\")(\"ant-btn-lg\", ctx.nzSize === \"large\")(\"ant-btn-sm\", ctx.nzSize === \"small\")(\"ant-btn-dangerous\", ctx.nzDanger)(\"ant-btn-loading\", ctx.nzLoading)(\"ant-btn-background-ghost\", ctx.nzGhost)(\"ant-btn-block\", ctx.nzBlock)(\"ant-input-search-button\", ctx.nzSearch)(\"ant-btn-rtl\", ctx.dir === \"rtl\")(\"ant-btn-icon-only\", ctx.iconOnly);\n        }\n      },\n      inputs: {\n        nzBlock: \"nzBlock\",\n        nzGhost: \"nzGhost\",\n        nzSearch: \"nzSearch\",\n        nzLoading: \"nzLoading\",\n        nzDanger: \"nzDanger\",\n        disabled: \"disabled\",\n        tabIndex: \"tabIndex\",\n        nzType: \"nzType\",\n        nzShape: \"nzShape\",\n        nzSize: \"nzSize\"\n      },\n      exportAs: [\"nzButton\"],\n      features: [i0.ɵɵNgOnChangesFeature],\n      attrs: _c0,\n      ngContentSelectors: _c1,\n      decls: 2,\n      vars: 1,\n      consts: [[\"nz-icon\", \"\", \"nzType\", \"loading\", 4, \"ngIf\"], [\"nz-icon\", \"\", \"nzType\", \"loading\"]],\n      template: function NzButtonComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, NzButtonComponent_span_0_Template, 1, 0, \"span\", 0);\n          i0.ɵɵprojection(1);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngIf\", ctx.nzLoading);\n        }\n      },\n      dependencies: [i3.NgIf, i4.NzIconDirective, i5.ɵNzTransitionPatchDirective],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"nzBlock\", void 0);\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"nzGhost\", void 0);\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"nzSearch\", void 0);\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"nzLoading\", void 0);\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"nzDanger\", void 0);\n  __decorate([InputBoolean()], NzButtonComponent.prototype, \"disabled\", void 0);\n  __decorate([WithConfig()], NzButtonComponent.prototype, \"nzSize\", void 0);\n  return NzButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzButtonGroupComponent = /*#__PURE__*/(() => {\n  class NzButtonGroupComponent {\n    constructor(directionality) {\n      this.directionality = directionality;\n      this.nzSize = 'default';\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n    }\n    ngOnInit() {\n      this.dir = this.directionality.value;\n      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    static #_ = this.ɵfac = function NzButtonGroupComponent_Factory(t) {\n      return new (t || NzButtonGroupComponent)(i0.ɵɵdirectiveInject(i2.Directionality, 8));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NzButtonGroupComponent,\n      selectors: [[\"nz-button-group\"]],\n      hostAttrs: [1, \"ant-btn-group\"],\n      hostVars: 6,\n      hostBindings: function NzButtonGroupComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ant-btn-group-lg\", ctx.nzSize === \"large\")(\"ant-btn-group-sm\", ctx.nzSize === \"small\")(\"ant-btn-group-rtl\", ctx.dir === \"rtl\");\n        }\n      },\n      inputs: {\n        nzSize: \"nzSize\"\n      },\n      exportAs: [\"nzButtonGroup\"],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function NzButtonGroupComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NzButtonGroupComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzButtonModule = /*#__PURE__*/(() => {\n  class NzButtonModule {\n    static #_ = this.ɵfac = function NzButtonModule_Factory(t) {\n      return new (t || NzButtonModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NzButtonModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [BidiModule, CommonModule, NzWaveModule, NzIconModule, ɵNzTransitionPatchModule, ɵNzTransitionPatchModule, NzWaveModule]\n    });\n  }\n  return NzButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzButtonComponent, NzButtonGroupComponent, NzButtonModule };\n//# sourceMappingURL=ng-zorro-antd-button.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
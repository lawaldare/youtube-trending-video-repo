{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i1 from '@angular/cdk/overlay';\nimport { ConnectionPositionPair, CdkOverlayOrigin } from '@angular/cdk/overlay';\nimport * as i0 from '@angular/core';\nimport { ElementRef, Directive, Input, NgModule } from '@angular/core';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i2 from 'ng-zorro-antd/core/services';\nimport { NzDestroyService } from 'ng-zorro-antd/core/services';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst POSITION_MAP = {\n  top: new ConnectionPositionPair({\n    originX: 'center',\n    originY: 'top'\n  }, {\n    overlayX: 'center',\n    overlayY: 'bottom'\n  }),\n  topCenter: new ConnectionPositionPair({\n    originX: 'center',\n    originY: 'top'\n  }, {\n    overlayX: 'center',\n    overlayY: 'bottom'\n  }),\n  topLeft: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'top'\n  }, {\n    overlayX: 'start',\n    overlayY: 'bottom'\n  }),\n  topRight: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'top'\n  }, {\n    overlayX: 'end',\n    overlayY: 'bottom'\n  }),\n  right: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'center'\n  }, {\n    overlayX: 'start',\n    overlayY: 'center'\n  }),\n  rightTop: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'top'\n  }, {\n    overlayX: 'start',\n    overlayY: 'top'\n  }),\n  rightBottom: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'bottom'\n  }, {\n    overlayX: 'start',\n    overlayY: 'bottom'\n  }),\n  bottom: new ConnectionPositionPair({\n    originX: 'center',\n    originY: 'bottom'\n  }, {\n    overlayX: 'center',\n    overlayY: 'top'\n  }),\n  bottomCenter: new ConnectionPositionPair({\n    originX: 'center',\n    originY: 'bottom'\n  }, {\n    overlayX: 'center',\n    overlayY: 'top'\n  }),\n  bottomLeft: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'bottom'\n  }, {\n    overlayX: 'start',\n    overlayY: 'top'\n  }),\n  bottomRight: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'bottom'\n  }, {\n    overlayX: 'end',\n    overlayY: 'top'\n  }),\n  left: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'center'\n  }, {\n    overlayX: 'end',\n    overlayY: 'center'\n  }),\n  leftTop: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'top'\n  }, {\n    overlayX: 'end',\n    overlayY: 'top'\n  }),\n  leftBottom: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'bottom'\n  }, {\n    overlayX: 'end',\n    overlayY: 'bottom'\n  })\n};\nconst DEFAULT_TOOLTIP_POSITIONS = [POSITION_MAP.top, POSITION_MAP.right, POSITION_MAP.bottom, POSITION_MAP.left];\nconst DEFAULT_CASCADER_POSITIONS = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topLeft, POSITION_MAP.topRight, POSITION_MAP.topCenter, POSITION_MAP.bottomCenter];\nconst DEFAULT_MENTION_TOP_POSITIONS = [new ConnectionPositionPair({\n  originX: 'start',\n  originY: 'bottom'\n}, {\n  overlayX: 'start',\n  overlayY: 'bottom'\n}), new ConnectionPositionPair({\n  originX: 'start',\n  originY: 'bottom'\n}, {\n  overlayX: 'end',\n  overlayY: 'bottom'\n})];\nconst DEFAULT_MENTION_BOTTOM_POSITIONS = [POSITION_MAP.bottomLeft, new ConnectionPositionPair({\n  originX: 'start',\n  originY: 'bottom'\n}, {\n  overlayX: 'end',\n  overlayY: 'top'\n})];\nfunction getPlacementName(position) {\n  for (const placement in POSITION_MAP) {\n    if (position.connectionPair.originX === POSITION_MAP[placement].originX && position.connectionPair.originY === POSITION_MAP[placement].originY && position.connectionPair.overlayX === POSITION_MAP[placement].overlayX && position.connectionPair.overlayY === POSITION_MAP[placement].overlayY) {\n      return placement;\n    }\n  }\n  return undefined;\n}\nconst DATE_PICKER_POSITION_MAP = {\n  bottomLeft: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'bottom'\n  }, {\n    overlayX: 'start',\n    overlayY: 'top'\n  }, undefined, 2),\n  topLeft: new ConnectionPositionPair({\n    originX: 'start',\n    originY: 'top'\n  }, {\n    overlayX: 'start',\n    overlayY: 'bottom'\n  }, undefined, -2),\n  bottomRight: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'bottom'\n  }, {\n    overlayX: 'end',\n    overlayY: 'top'\n  }, undefined, 2),\n  topRight: new ConnectionPositionPair({\n    originX: 'end',\n    originY: 'top'\n  }, {\n    overlayX: 'end',\n    overlayY: 'bottom'\n  }, undefined, -2)\n};\nconst DEFAULT_DATE_PICKER_POSITIONS = [DATE_PICKER_POSITION_MAP.bottomLeft, DATE_PICKER_POSITION_MAP.topLeft, DATE_PICKER_POSITION_MAP.bottomRight, DATE_PICKER_POSITION_MAP.topRight];\nlet NzConnectedOverlayDirective = /*#__PURE__*/(() => {\n  class NzConnectedOverlayDirective {\n    constructor(cdkConnectedOverlay, nzDestroyService) {\n      this.cdkConnectedOverlay = cdkConnectedOverlay;\n      this.nzDestroyService = nzDestroyService;\n      this.nzArrowPointAtCenter = false;\n      this.cdkConnectedOverlay.backdropClass = 'nz-overlay-transparent-backdrop';\n      this.cdkConnectedOverlay.positionChange.pipe(takeUntil(this.nzDestroyService)).subscribe(position => {\n        if (this.nzArrowPointAtCenter) {\n          this.updateArrowPosition(position);\n        }\n      });\n    }\n    updateArrowPosition(position) {\n      const originRect = this.getOriginRect();\n      const placement = getPlacementName(position);\n      let offsetX = 0;\n      let offsetY = 0;\n      if (placement === 'topLeft' || placement === 'bottomLeft') {\n        offsetX = originRect.width / 2 - 14;\n      } else if (placement === 'topRight' || placement === 'bottomRight') {\n        offsetX = -(originRect.width / 2 - 14);\n      } else if (placement === 'leftTop' || placement === 'rightTop') {\n        offsetY = originRect.height / 2 - 10;\n      } else if (placement === 'leftBottom' || placement === 'rightBottom') {\n        offsetY = -(originRect.height / 2 - 10);\n      }\n      if (this.cdkConnectedOverlay.offsetX !== offsetX || this.cdkConnectedOverlay.offsetY !== offsetY) {\n        this.cdkConnectedOverlay.offsetY = offsetY;\n        this.cdkConnectedOverlay.offsetX = offsetX;\n        this.cdkConnectedOverlay.overlayRef.updatePosition();\n      }\n    }\n    getFlexibleConnectedPositionStrategyOrigin() {\n      if (this.cdkConnectedOverlay.origin instanceof CdkOverlayOrigin) {\n        return this.cdkConnectedOverlay.origin.elementRef;\n      } else {\n        return this.cdkConnectedOverlay.origin;\n      }\n    }\n    getOriginRect() {\n      const origin = this.getFlexibleConnectedPositionStrategyOrigin();\n      if (origin instanceof ElementRef) {\n        return origin.nativeElement.getBoundingClientRect();\n      }\n      // Check for Element so SVG elements are also supported.\n      if (origin instanceof Element) {\n        return origin.getBoundingClientRect();\n      }\n      const width = origin.width || 0;\n      const height = origin.height || 0;\n      // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n      return {\n        top: origin.y,\n        bottom: origin.y + height,\n        left: origin.x,\n        right: origin.x + width,\n        height,\n        width\n      };\n    }\n    static #_ = this.ɵfac = function NzConnectedOverlayDirective_Factory(t) {\n      return new (t || NzConnectedOverlayDirective)(i0.ɵɵdirectiveInject(i1.CdkConnectedOverlay), i0.ɵɵdirectiveInject(i2.NzDestroyService));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NzConnectedOverlayDirective,\n      selectors: [[\"\", \"cdkConnectedOverlay\", \"\", \"nzConnectedOverlay\", \"\"]],\n      inputs: {\n        nzArrowPointAtCenter: \"nzArrowPointAtCenter\"\n      },\n      exportAs: [\"nzConnectedOverlay\"],\n      features: [i0.ɵɵProvidersFeature([NzDestroyService])]\n    });\n  }\n  __decorate([InputBoolean()], NzConnectedOverlayDirective.prototype, \"nzArrowPointAtCenter\", void 0);\n  return NzConnectedOverlayDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzOverlayModule = /*#__PURE__*/(() => {\n  class NzOverlayModule {\n    static #_ = this.ɵfac = function NzOverlayModule_Factory(t) {\n      return new (t || NzOverlayModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NzOverlayModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NzOverlayModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DATE_PICKER_POSITION_MAP, DEFAULT_CASCADER_POSITIONS, DEFAULT_DATE_PICKER_POSITIONS, DEFAULT_MENTION_BOTTOM_POSITIONS, DEFAULT_MENTION_TOP_POSITIONS, DEFAULT_TOOLTIP_POSITIONS, NzConnectedOverlayDirective, NzOverlayModule, POSITION_MAP, getPlacementName };\n//# sourceMappingURL=ng-zorro-antd-core-overlay.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}